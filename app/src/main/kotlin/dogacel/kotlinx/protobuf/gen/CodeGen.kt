package dogacel.kotlinx.protobuf.gen

import com.google.protobuf.Descriptors
import com.google.protobuf.compiler.PluginProtos
import com.squareup.kotlinpoet.*
import dogacel.kotlinx.protobuf.gen.DefaultValues.defaultValueOf
import kotlinx.serialization.Serializable
import java.nio.file.Path
import java.util.*
import kotlin.io.path.Path

data class CodeGeneratorOptions(
    val packagePrefix: String = "",
    val useCamelCase: Boolean = true,
    val autoGenerateDependencies: Boolean = true,
)

fun String.toLowerCamelCase(): String {
    val snakeRegex = "_[a-zA-Z]".toRegex()
    return snakeRegex.replace(this) {
        it.value.replace("_", "").uppercase(Locale.ENGLISH)
    }
}

/**
 * A class that generates the Kotlin code for the given [PluginProtos.CodeGeneratorRequest].
 * This request is sent via the protobuf compiler plugin.
 */
class CodeGenerator {
    private val typeNames: Map<Descriptors.GenericDescriptor, TypeName>
    private val filesInOrder: List<Descriptors.FileDescriptor>
    private val options: CodeGeneratorOptions

    constructor(
        request: PluginProtos.CodeGeneratorRequest,
        options: CodeGeneratorOptions = CodeGeneratorOptions()
    ) {
        this.options = options
        // https://protobuf.dev/reference/java/api-docs/com/google/protobuf/compiler/PluginProtos.CodeGeneratorRequest
        // FileDescriptorProtos for all files in files_to_generate and everything
        // they import.  The files will appear in topological order, so each file
        // appears before any file that imports it.
        val files = mutableMapOf<String, Descriptors.FileDescriptor>()
        filesInOrder = request.protoFileList.map { file ->
            files.computeIfAbsent(
                file.name,
            ) {
                val deps = file.dependencyList.map { dep ->
                    files[dep] ?: throw IllegalStateException("Dependency $dep not found for file ${file.name}")
                }
                Descriptors.FileDescriptor.buildFrom(file, deps.toTypedArray())
            }
        }
        typeNames = filesInOrder.flatMap { fileDescriptor ->
            buildClassSpecs(fileDescriptor, options.packagePrefix)
        }.toMap()
    }

    constructor(
        vararg fileDescriptors: Descriptors.FileDescriptor,
        options: CodeGeneratorOptions = CodeGeneratorOptions()
    ) {
        this.options = options

        if (options.autoGenerateDependencies) {
            // Extract dependencies and topologically sort the descriptors.
            val depths = mutableMapOf<Descriptors.FileDescriptor, Int>()

            fun calculator(descriptors: List<Descriptors.FileDescriptor>, depth: Int = 0) {
                descriptors.forEach {
                    depths.computeIfAbsent(it) { 0 }
                    depths[it] = depth.coerceAtLeast(depths[it]!!)

                    calculator(it.dependencies, depth + 1)
                    calculator(it.publicDependencies, depth + 1)
                }
            }

            calculator(fileDescriptors.toList())

            filesInOrder = depths.entries.sortedByDescending { it.value }.map { it.key }
        } else {
            // Assume dependencies and files come in order
            filesInOrder = fileDescriptors.toList()
        }
        typeNames = filesInOrder.flatMap { fileDescriptor ->
            buildClassSpecs(fileDescriptor, options.packagePrefix)
        }.toMap()
    }

    /**
     * Generate the source files to the given [path].
     */
    fun generate(path: Path = Path("./generated")) {
        filesInOrder.forEach { fileDescriptor ->
            val fileSpec = generateSingleFile(fileDescriptor)
            fileSpec.build().writeTo(path)
        }
    }

    /**
     * Generate the code for the given [Descriptors.FileDescriptor]. Returns a [FileSpec.Builder] so users
     * can add additional code to the file.
     *
     * A file contains classes and enums.
     *
     * @param fileDescriptor [Descriptors.FileDescriptor] to generate code for.
     * @return [FileSpec.Builder] that contains the generated code.
     */
    private fun generateSingleFile(fileDescriptor: Descriptors.FileDescriptor): FileSpec.Builder {
        val packageName = if (options.packagePrefix.isNotEmpty()) {
            options.packagePrefix + '.' + fileDescriptor.`package`
        } else {
            fileDescriptor.`package`
        }

        val fileName = fileDescriptor.name.substringAfterLast('/')
        val fileSpec = FileSpec.builder(packageName, fileName)

        fileDescriptor.messageTypes.forEach { messageType ->
            val typeSpec = generateSingleClass(messageType)
            fileSpec.addType(typeSpec.build())
        }

        fileDescriptor.enumTypes.forEach { enumType ->
            val typeSpec = generateSingleEnum(enumType)
            fileSpec.addType(typeSpec.build())
        }

        return fileSpec
    }

    /**
     * Generate a single parameter for the given [Descriptors.FieldDescriptor]. Returns a
     * [ParameterSpec.Builder] so users can add additional code to the parameter.
     *
     * A parameter contains a name, type and default value. Parameters are used in constructors.
     *
     * @param fieldDescriptor [Descriptors.FieldDescriptor] to generate code for.
     * @return [ParameterSpec.Builder] that contains the generated code.
     */
    private fun generateSingleParameter(fieldDescriptor: Descriptors.FieldDescriptor): ParameterSpec.Builder {
        val fieldTypeName = TypeNames.typeNameOf(fieldDescriptor, typeNames)

        val fieldName = if (options.useCamelCase) {
            fieldDescriptor.name.toLowerCamelCase()
        } else {
            fieldDescriptor.name
        }

        val defaultValue = defaultValueOf(fieldDescriptor, typeNames)

        return ParameterSpec.builder(fieldName, fieldTypeName)
            .addAnnotations(Annotations.annotationsOf(fieldDescriptor))
            .defaultValue("%L", defaultValue)
    }

    /**
     * Generate a single class for the given [Descriptors.Descriptor]. Returns a [TypeSpec.Builder] so users
     * can add additional code to the class.
     *
     * A class contains subclasses, enums, parameters and properties.
     *
     * @param messageType [Descriptors.Descriptor] to generate code for.
     * @return [TypeSpec.Builder] that contains the generated code.
     */
    private fun generateSingleClass(messageType: Descriptors.Descriptor): TypeSpec.Builder {
        val typeSpec = TypeSpec.classBuilder(messageType.name)
            .addModifiers(KModifier.DATA)
            .addAnnotation(Serializable::class)

        val constructor = FunSpec.constructorBuilder().also { builder ->
            messageType.fields.forEach {
                builder
                    .addParameter(
                        generateSingleParameter(it).build()
                    )
            }
        }.build()

        typeSpec.primaryConstructor(constructor)


        messageType.fields.forEach {
            val type = TypeNames.typeNameOf(it, typeNames)
            val fieldName = if (options.useCamelCase) {
                it.name.toLowerCamelCase()
            } else {
                it.name
            }

            typeSpec.addProperty(
                PropertySpec.builder(fieldName, type)
                    .initializer(fieldName)
                    .build()
            )
        }

        val nestedTypes = messageType.nestedTypes.filterNot {
            it.options.mapEntry
        }.map {
            generateSingleClass(it).build()
        }
        typeSpec.addTypes(nestedTypes)

        val nestedEnums = messageType.enumTypes.map {
            generateSingleEnum(it).build()
        }
        typeSpec.addTypes(nestedEnums)

        return typeSpec
    }

    /**
     * Generate a single enum for the given [Descriptors.EnumDescriptor]. Returns a [TypeSpec.Builder] so users
     * can add additional code to the enum.
     *
     * An enum contains enum constants.
     *
     * @param enumDescriptor [Descriptors.EnumDescriptor] to generate code for.
     * @return [TypeSpec.Builder] that contains the generated code.
     */
    private fun generateSingleEnum(enumDescriptor: Descriptors.EnumDescriptor): TypeSpec.Builder {
        val typeSpec = TypeSpec
            .enumBuilder(enumDescriptor.name)
            .addAnnotation(Serializable::class)

        enumDescriptor.values.forEach { valueDescriptor ->
            typeSpec.addEnumConstant(
                valueDescriptor.name,
                TypeSpec.anonymousClassBuilder()
                    .addAnnotations(Annotations.annotationsOf(valueDescriptor))
                    .build()
            )
        }

        return typeSpec
    }


    private fun buildEnumSpecs(
        enumDescriptor: Descriptors.EnumDescriptor,
        packageName: String,
        simpleNames: List<String>
    ): Pair<Descriptors.GenericDescriptor, ClassName> {
        return Pair(
            enumDescriptor,
            ClassName(packageName, simpleNames + enumDescriptor.name)
        )
    }

    private fun buildClassSpecs(
        descriptor: Descriptors.Descriptor,
        packageName: String,
        simpleNames: List<String>
    ): List<Pair<Descriptors.GenericDescriptor, ClassName>> {
        val messages = descriptor.nestedTypes.flatMap { nestedType ->
            buildClassSpecs(nestedType, packageName, simpleNames + descriptor.name)
        }

        val enums = descriptor.enumTypes.map {
            buildEnumSpecs(it, packageName, simpleNames + descriptor.name)
        }

        val self = Pair(
            descriptor,
            ClassName(packageName, simpleNames + descriptor.name)
        )
        return (messages + enums + self)
    }

    private fun buildClassSpecs(
        fileDescriptor: Descriptors.FileDescriptor,
        packagePrefix: String = ""
    ): List<Pair<Descriptors.GenericDescriptor, ClassName>> {
        val publicDependencies = fileDescriptor.publicDependencies.flatMap {
            buildClassSpecs(it, packagePrefix)
        }

        val dependencies = fileDescriptor.dependencies.flatMap {
            buildClassSpecs(it, packagePrefix)
        }

        val packageName = if (packagePrefix.isNotEmpty()) {
            packagePrefix + '.' + fileDescriptor.`package`
        } else {
            fileDescriptor.`package`
        }

        val messages = fileDescriptor.messageTypes.flatMap {
            buildClassSpecs(it, packageName, listOf())
        }

        val enums = fileDescriptor.enumTypes.map {
            buildEnumSpecs(it, packageName, listOf())
        }

        return (publicDependencies + dependencies + messages + enums)
    }
}
