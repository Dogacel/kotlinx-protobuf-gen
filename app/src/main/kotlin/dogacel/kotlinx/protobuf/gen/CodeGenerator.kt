package dogacel.kotlinx.protobuf.gen

import com.google.protobuf.Descriptors
import com.google.protobuf.compiler.PluginProtos
import com.squareup.kotlinpoet.*
import dogacel.kotlinx.protobuf.gen.DefaultValues.defaultValueOf
import dogacel.kotlinx.protobuf.gen.Utils.toLowerCamelCaseIf
import kotlinx.serialization.Serializable
import java.nio.file.Path
import kotlin.io.path.Path

/**
 * Links are used to keep track of the [TypeName] of the fields and the types they reference before the code
 * is generated. This way, code generation of types do not depend on each other and can be generated in any
 * order. A type is defined as [Descriptors.GenericDescriptor] which is a common interface for all descriptors.
 * Corresponding kotlin definition type is stored in a [TypeName] which comes from `kotlinpoet` library.
 */
private typealias Link = Pair<Descriptors.GenericDescriptor, TypeName>

/**
 * A map of [Link]s that can be accessed using property access syntax.
 */
private typealias TypeLinks = Map<Descriptors.GenericDescriptor, TypeName>

/**
 * A class that generates the Kotlin code for the given protobuf files.
 */
class CodeGenerator {

    private val typeLinks: TypeLinks
    private val filesInOrder: List<Descriptors.FileDescriptor>
    private val options: CodeGeneratorOptions

    /**
     * Create a code generator for the given [PluginProtos.CodeGeneratorRequest]. This request is created from
     * the protoc compiler.
     */
    constructor(
        request: PluginProtos.CodeGeneratorRequest,
        options: CodeGeneratorOptions = CodeGeneratorOptions()
    ) {
        this.options = options
        // https://protobuf.dev/reference/java/api-docs/com/google/protobuf/compiler/PluginProtos.CodeGeneratorRequest
        // FileDescriptorProtos for all files in files_to_generate and everything
        // they import.  The files will appear in topological order, so each file
        // appears before any file that imports it.
        val files = mutableMapOf<String, Descriptors.FileDescriptor>()
        filesInOrder = request.protoFileList.map { file ->
            files.computeIfAbsent(
                file.name
            ) {
                val deps = file.dependencyList.map { dep ->
                    files[dep] ?: throw IllegalStateException("Dependency $dep not found for file ${file.name}")
                }
                Descriptors.FileDescriptor.buildFrom(file, deps.toTypedArray())
            }
        }
        typeLinks = filesInOrder.flatMap { fileDescriptor ->
            getAllLinks(fileDescriptor, options.packagePrefix)
        }.toMap()
    }

    /**
     * Create a code generator for the given [Descriptors.FileDescriptor]s. This is useful if you want to
     * generate code for a subset of the files in a proto package.
     */
    constructor(
        vararg fileDescriptors: Descriptors.FileDescriptor,
        options: CodeGeneratorOptions = CodeGeneratorOptions()
    ) {
        this.options = options

        if (options.autoGenerateDependencies) {
            // Extract dependencies and topologically sort the descriptors.
            val depths = mutableMapOf<Descriptors.FileDescriptor, Int>()

            fun calculator(descriptors: List<Descriptors.FileDescriptor>, depth: Int = 0) {
                descriptors.forEach {
                    depths.computeIfAbsent(it) { 0 }
                    depths[it] = depth.coerceAtLeast(depths[it]!!)

                    calculator(it.dependencies, depth + 1)
                    calculator(it.publicDependencies, depth + 1)
                }
            }

            calculator(fileDescriptors.toList())

            filesInOrder = depths.entries.sortedByDescending { it.value }.map { it.key }
        } else {
            // Assume dependencies and files come in order
            filesInOrder = fileDescriptors.toList()
        }
        typeLinks = filesInOrder.flatMap { fileDescriptor ->
            getAllLinks(fileDescriptor, options.packagePrefix)
        }.toMap()
    }

    /**
     * Generate the source files to the given [path].
     */
    fun generateFiles(path: Path = Path("./generated")) {
        generateFileSpecs().forEach { file ->
            file.writeTo(path)
        }
    }

    /**
     * Generate the file specs that contain the generated code without persisting them.
     */
    fun generateFileSpecs(): List<FileSpec> {
        return filesInOrder.map { fileDescriptor ->
            generateSingleFile(fileDescriptor).build()
        }
    }

    /**
     * Generate the code for the given [Descriptors.FileDescriptor]. Returns a [FileSpec.Builder] so users
     * can add additional code to the file.
     *
     * A file contains classes and enums.
     *
     * @param fileDescriptor [Descriptors.FileDescriptor] to generate code for.
     * @return [FileSpec.Builder] that contains the generated code.
     */
    private fun generateSingleFile(fileDescriptor: Descriptors.FileDescriptor): FileSpec.Builder {
        val packageName = if (options.packagePrefix.isNotEmpty()) {
            options.packagePrefix + '.' + fileDescriptor.`package`
        } else {
            fileDescriptor.`package`
        }

        val fileName = fileDescriptor.name.substringAfterLast('/')
        val fileSpec = FileSpec.builder(packageName, fileName)

        fileDescriptor.messageTypes.forEach { messageType ->
            val typeSpec = generateSingleClass(messageType)
            fileSpec.addType(typeSpec.build())
        }

        fileDescriptor.enumTypes.forEach { enumType ->
            val typeSpec = generateSingleEnum(enumType)
            fileSpec.addType(typeSpec.build())
        }

        return fileSpec
    }

    /**
     * Generate a single parameter for the given [Descriptors.FieldDescriptor]. Returns a
     * [ParameterSpec.Builder] so users can add additional code to the parameter.
     *
     * A parameter contains a name, type and default value. Parameters are used in constructors.
     *
     * @param fieldDescriptor [Descriptors.FieldDescriptor] to generate code for.
     * @return [ParameterSpec.Builder] that contains the generated code.
     */
    private fun generateSingleParameter(fieldDescriptor: Descriptors.FieldDescriptor): ParameterSpec.Builder {
        val fieldTypeName = TypeNames.typeNameOf(fieldDescriptor, typeLinks)
        val fieldName = fieldDescriptor.name.toLowerCamelCaseIf(options.useCamelCase)

        val defaultValue = defaultValueOf(fieldDescriptor, typeLinks)

        return ParameterSpec.builder(fieldName, fieldTypeName)
            .addAnnotations(Annotations.annotationsOf(fieldDescriptor))
            .defaultValue("%L", defaultValue)
    }

    /**
     * Generate a single class for the given [Descriptors.Descriptor]. Returns a [TypeSpec.Builder] so users
     * can add additional code to the class.
     *
     * A class contains subclasses, enums, parameters and properties.
     *
     * @param messageType [Descriptors.Descriptor] to generate code for.
     * @return [TypeSpec.Builder] that contains the generated code.
     */
    private fun generateSingleClass(messageType: Descriptors.Descriptor): TypeSpec.Builder {
        val typeSpec = TypeSpec.classBuilder(messageType.name)
            .addModifiers(KModifier.DATA)
            .addAnnotation(Serializable::class)


        // A Data class needs a primary constructor with all the parameters.
        val parameters = messageType.fields.map { generateSingleParameter(it).build() }
        val constructorSpec = FunSpec
            .constructorBuilder()
            .addParameters(parameters)

        // A trick to handle oneof fields. We need to make sure that only one of the fields is set.
        // Validation is done in `init` block so objects in invalid states can't be initialized.
        messageType.oneofs.forEach { oneOfDescriptor ->
            if (!oneOfDescriptor.isSynthetic && oneOfDescriptor.fields.isNotEmpty()) {
                val codeSpec = CodeBlock.builder()
                codeSpec.addStatement("require(")
                codeSpec.indent()
                codeSpec.addStatement("listOfNotNull(")
                codeSpec.indent()
                oneOfDescriptor.fields.forEach {
                    codeSpec.addStatement("%L,", it.name.toLowerCamelCaseIf(options.useCamelCase))
                }
                codeSpec.unindent()
                codeSpec.addStatement(").size <= 1")
                codeSpec.unindent()
                codeSpec.addStatement(") { \"Should only contain one of ${oneOfDescriptor.name}.\" } ")
                constructorSpec.addCode(codeSpec.build())
            }
        }

        typeSpec.primaryConstructor(constructorSpec.build())

        // A data class should define all parameters in constructors as parameters using `val` keyword.
        messageType.fields.forEach { fieldDescriptor ->
            val type = TypeNames.typeNameOf(fieldDescriptor, typeLinks)
            val fieldName = fieldDescriptor.name.toLowerCamelCaseIf(options.useCamelCase)

            typeSpec.addProperty(
                PropertySpec.builder(fieldName, type)
                    .initializer(fieldName)
                    .build()
            )
        }

        // Recursively generate nested classes and enums.
        val nestedTypes = messageType.nestedTypes.filterNot {
            it.options.mapEntry
        }.map {
            generateSingleClass(it).build()
        }
        typeSpec.addTypes(nestedTypes)

        val nestedEnums = messageType.enumTypes.map {
            generateSingleEnum(it).build()
        }
        typeSpec.addTypes(nestedEnums)

        return typeSpec
    }

    /**
     * Generate a single enum for the given [Descriptors.EnumDescriptor]. Returns a [TypeSpec.Builder] so users
     * can add additional code to the enum.
     *
     * An enum contains enum constants.
     *
     * @param enumDescriptor [Descriptors.EnumDescriptor] to generate code for.
     * @return [TypeSpec.Builder] that contains the generated code.
     */
    private fun generateSingleEnum(enumDescriptor: Descriptors.EnumDescriptor): TypeSpec.Builder {
        val typeSpec = TypeSpec
            .enumBuilder(enumDescriptor.name)
            .addAnnotation(Serializable::class)

        enumDescriptor.values.forEach { valueDescriptor ->
            typeSpec.addEnumConstant(
                valueDescriptor.name,
                TypeSpec.anonymousClassBuilder()
                    .addAnnotations(Annotations.annotationsOf(valueDescriptor))
                    .build()
            )
        }

        return typeSpec
    }

    /**
     * Get a [Link] to the given [Descriptors.EnumDescriptor].
     *
     * @param simpleNames if class is nested, all parent class names.
     */
    private fun getEnumLink(
        enumDescriptor: Descriptors.EnumDescriptor,
        packageName: String,
        simpleNames: List<String>
    ): Link {
        return Link(
            enumDescriptor,
            ClassName(packageName, simpleNames + enumDescriptor.name)
        )
    }

    /**
     * Get all [Link]s for the type defined in the given [Descriptors.Descriptor] and nested types. Those nested
     * types can be other messages or enums.
     *
     * @param simpleNames if class is nested, all parent class names.
     */
    private fun getAllLinks(
        descriptor: Descriptors.Descriptor,
        packageName: String,
        simpleNames: List<String>
    ): List<Link> {
        val messages = descriptor.nestedTypes.flatMap { nestedType ->
            getAllLinks(nestedType, packageName, simpleNames + descriptor.name)
        }

        val enums = descriptor.enumTypes.map {
            getEnumLink(it, packageName, simpleNames + descriptor.name)
        }

        val self = Link(
            descriptor,
            ClassName(packageName, simpleNames + descriptor.name)
        )
        return (messages + enums + self)
    }

    /**
     * Get all [Link]s a file descriptor contains. This includes all message types, enums and dependencies.
     *
     * @param packagePrefix Prefix to add to the package name of the file descriptor.
     */
    private fun getAllLinks(
        fileDescriptor: Descriptors.FileDescriptor,
        packagePrefix: String = ""
    ): List<Link> {
        val publicDependencies = fileDescriptor.publicDependencies.flatMap {
            getAllLinks(it, packagePrefix)
        }

        val dependencies = fileDescriptor.dependencies.flatMap {
            getAllLinks(it, packagePrefix)
        }

        val packageName = if (packagePrefix.isNotEmpty()) {
            packagePrefix + '.' + fileDescriptor.`package`
        } else {
            fileDescriptor.`package`
        }

        val messages = fileDescriptor.messageTypes.flatMap {
            getAllLinks(it, packageName, listOf())
        }

        val enums = fileDescriptor.enumTypes.map {
            getEnumLink(it, packageName, listOf())
        }

        return (publicDependencies + dependencies + messages + enums)
    }
}
